# 设计模式



## 设计原则

- **单一职责**

  一个对象或函数只做一件事。

- **最少知识**

  软件实体(类、模块、函数)之间尽可能减少交互;可交由第三方处理。

- **开闭原则**

  软件实体(类、模块、函数)可进行扩展，但不可修改。





## 常用模式

### 单例模式

**理解**: 一个类只有一个实例，并可全局访问。





### 策略模式

**理解**: 将程序划分为策略类(程序实现)和环境类(程序调用),使得用户请求指令时委托某一策略类进行不同计算。

**策略类**: 程序实现。

**环境类**: 用户请求指令的调用。

**案例**: 输入验证。



### 代理模式

**理解**: 为一个对象提供替身对象或占位。本体跟代理的接口具备一致性(可以说是参数一致),代理对象实际上是对本体对象的引用,是否进行提供或拒绝接口,并进行一些额外程序实现。

**类型**: 保护代理, 虚拟代理, 缓存代理。

- 保护代理

  对主体访问进行限制。

- 虚拟代理

  在代理对象增加额外的程序处理。

- 缓存代理

  对开销大的程序结果进行缓存,提高效率。





### 迭代器模式

**理解**: 提供一种按顺序访问聚合对象内部结构内容的方法,但不对外进行暴露(可理解类似的 map() 方法)。

**案例**: JavaScript Map() 方法



### 发布-订阅模式(观察模式)

**理解**: 定义了对象间一对多的依赖关系:当对象发生变化,所依赖它的所有对象都会得到通知进行相应响应。

**案例**: 监听事件的触发。





### 命令模式

**理解**: 使用命令来执行特定内容的程序,一般提供包含执行(execute),撤销(undo),重做(redo)等功能。

**案例**: 文本编辑器。



### 组合模式

小对象: 叶对象。

大对象: 组合对象。

**理解**: 以小(叶)对象聚合构成大(组合)对象,小对象与大对象是一种聚合的关系。当用户请求委托给组合对象的所有叶对象，所以需要保证组合对象与叶对象的方法一致。

**案例**: 主干树-分支杈结构



### 模板方法模式

**理解**: 定义抽象父类和实现子类。将公共部分的方法和子类的算法程序进行封装到抽象父类, 由实现子类根据不同业务进行不同的逻辑实现，也可重写抽象父类的方法。**模板方法模式实现方式是继承**。

**案例**: 运动活动前热身与不同运动的规则处理。





### 享元模式

**理解**: 尽量减少共享数据对象的数量(属性对象划分内部共享属性和外部场景属性),达到性能优化的模式。

**案例**: 暂无案例





### 职责链模式





### 中介者模式

**理解**: 将多对多的对象关系, 通过中介对象进行程序通信,达到一对多的关系。当一个对象发生改变,只要通知中介对象就行了,且复杂的调度任务交给中介对象进行处理。







### 装饰者模式

**理解**: 动态地为对象加入额外的行为, 经过装饰封装形成装饰链。





### 状态模式





### 适配器模式



### 外观模式